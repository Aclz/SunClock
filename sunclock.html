<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<style>
.evenhour {
	/*fill: #ffcbf6;*/
	fill: none;
	stroke: #000000;
	stroke-width: 0.5;
}

.oddhour {
	/*fill: #cfffd8;*/
	fill: none;
	stroke: #000000;
	stroke-width: 0.5;
}

.nighthour {
	/*fill: #7f7faf;*/
	fill: none;
	/*stroke: #7f7faf;*/
	stroke: #000000;
	stroke-width: 0.5;
}

.clocklabel {
	fill: #000000;
	stroke: #ffffff;
	font-family: "Verdana";
	font-weight: bold;
	font-size: 17pt;
	stroke-width: 1.5;
}

.timeequationlabel {
	fill: #000000;
    stroke: none;
	font-family: "Verdana";
	font-size: 8pt;
}

.monthlabel {
	fill: #000000;
    stroke: none;
	font-family: "Verdana";
    font-weight: bold;
	font-size: 8pt;
}

.monthlabelbg {
	fill: #ffffff;
    stroke: #ffffff;
    opacity: 0.85;
	font-family: "Verdana";
    font-weight: bold;
	font-size: 8pt;
    stroke-width: 6;
}

.timeequationcaption {
	fill: #000000;
    stroke: none;
	font-family: "Verdana";
	font-weight: bold;
	font-size: 9pt;
}

.monthsline {
	stroke: #000000;
	stroke-width: 1.5;
	fill: none;
}

.specialdaysline {
	stroke: #ff0000;
	stroke-width: 1;
	fill: none;
}

.timeequationline {
	stroke: #ff0000;
	stroke-width: 2;
	fill: none;
}

.axisline {
	stroke: #3f3f3f;
	stroke-width: 0.5;
}

.gnomontopmark {
	stroke: #7f7f7f;
	stroke-width: 1;
}

.gnomonlengthmark {
	stroke: #7f7f7f;
	stroke-width: 1;
}
 
.hourline {
	stroke: #7f7f7f;
	stroke-width: 0.5;
}

</style>
</head>
<body>
<svg id="timeclock" width="800" height="1000" xmlns="http://www.w3.org/2000/svg" />
<svg id="dateclock" width="800" height="1000" style="fill:none;stroke:black;stroke-width:3" xmlns="http://www.w3.org/2000/svg" />
<script>
//Физические и географические константы
const axisIncline = 23.44*Math.PI/180;
const lat = 56.83*Math.PI/180;
const lon = 60.57*Math.PI/180;
const timeZone = 5;
const shortestDayCorrection = 10.75;
const firstDaysOfMonths = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
const specialDays = [365/4 - 10.75, 365/2 - 10.75, 365 - 10.75];
const celsiusTemperature = 0;
const altitude = 350; //in meters above sea level
const seaLevelPressure = 760*133.3/1000; //in kPa

//Константы рисования
const clock1ScaleFactor = 340;
const clock1ShiftDown = 270;
const clock1hourFractions = 16;
const clock1hourSubdivs = 3;

const clock2ScaleFactor = 110;
const clock2ShiftDown = 730;
const clock2hourFractions = 8;

const timeEquationTopX = 0.33;
const timeEquationTopY = 1.65;

const hourLabelShift = -0.1;
const H = 1; //"Высота" гномона (длина относительно центра циферблата до кончика)

//Вычисляемые переменные
var clock1ShiftLeft = 800/2 - clock1ScaleFactor;
var clock2ShiftLeft = 800/2 - clock2ScaleFactor;
var timeshift = ((lon*180/Math.PI)*24/360 - timeZone)/24; // -1/24
var clockFaceDistorsion = 1.7;
var gnomonHeight = H*Math.sin(lat);
var barometricPressure = seaLevelPressure*Math.exp(-0.029*9.81*altitude/8.31/(celsiusTemperature + 273)); //in kPa
var timeEquationWidth = 2 - 2*timeEquationTopX;
var timeEquationHeight = 2.08 - timeEquationTopY;

function cx1(x, offset) {
	return x*clock1ScaleFactor + clock1ShiftLeft + (offset ? offset : 0);
}

function cy1(y, offset) {
	return y*clock1ScaleFactor + clock1ShiftDown + (offset ? offset : 0);
}

function cx2(x, offset) {
	return x*clock2ScaleFactor + clock2ShiftLeft + (offset ? offset : 0);
}

function cy2(y, offset) {
	return y*clock2ScaleFactor + clock2ShiftDown + (offset ? offset : 0);
}

function corrDate(day) {
	//d_uncorr – нескорректированная "дата" (изменяется в промежутке от 0 до 1)
	var d_uncorr = day/365;

	//d – скорректированная дата
	return d_uncorr + shortestDayCorrection/365;
}

function corrTime(hours) {
	return hours/24 + timeshift;
}

function ortodromy(lat1, lon1, lat2, lon2) {
	var arcAngleLength = Math.acos(Math.sin(lat1)*Math.sin(lat2) + Math.cos(lat1)*Math.cos(lat2)*Math.cos(lon2 - lon1));
	
	if (lon2 == lon1)
		var srcAzimuth = (lat2 > lat1 ? 0 : Math.PI)
	else
		var srcAzimuth = Math.PI/2 - Math.atan(Math.cos(lat1)*Math.tan(lat2)/Math.sin(lon2 - lon1) - Math.sin(lat1)/Math.tan(lon2 - lon1)) +
			(Math.sin(lon2 - lon1) > 0 ? 0 : Math.PI);
		
	srcAzimuth = (srcAzimuth < 0 ? srcAzimuth + Math.PI : srcAzimuth);
	
	return {arcAngleLength: arcAngleLength, srcAzimuth: srcAzimuth};
}

function time_equation_correction(day) {
	var b = 2*Math.PI*(day - 81)/365;
	
	return (7.53*Math.cos(b) + 1.5*Math.sin(b) - 9.87*Math.sin(2*b))/60;
}

//β – широта солнца
function beta(day, hours) {
	var d = corrDate(day);
	
	return -axisIncline*Math.cos(2*Math.PI*d);
}

//ω – долгота солнца
function omega(day, hours) {
	var t = (12 - hours + timeZone + time_equation_correction(day))/24;
	
	if (t < 0)
		t = t + 1;
	
	return 2*Math.PI*(t);
}

//φ – азимут солнца в моем местоположении
function phi(day, hours) {
	return ortodromy(lat, lon, beta(day, hours), omega(day, hours)).srcAzimuth;
}

//Рефракция атмосферы
function refractionCorrection(zeta) {
    var zetaInDegrees = zeta*180/Math.PI;
    var resultInMinutesOfArc = 1/Math.tan((zetaInDegrees + 7.31/(zetaInDegrees + 4.4))*Math.PI/180);
    
    resultInMinutesOfArc = resultInMinutesOfArc*barometricPressure/101*283/(273 + celsiusTemperature);
    
    return resultInMinutesOfArc*Math.PI/180/60;
}

//ζ – угол подъема солнца над горизонтом в моем местоположении
function zeta(day, hours) {
    var result = Math.PI/2 - ortodromy(lat, lon, beta(day, hours), omega(day, hours)).arcAngleLength;

	return result + refractionCorrection(result);
}

//координаты вершины гномона на плоскости часов относительно азимута солнца и высоты над горизонтом
function gnomonTopProjection(day, hours) {
	//Длина тени гномона, если бы он был вертикальным (но той же высоты)
	var shadowLength = gnomonHeight/Math.tan(zeta(day, hours));
	
	//Координаты тени гномона, если бы он был вертикальным (но той же высоты)
	var xVerticalGnomon = shadowLength*Math.sin(phi(day, hours));
	var yVerticalGnomon = shadowLength*Math.cos(phi(day, hours));
	
	//Смещения вершины гномона относительно начала координат
	var xInclinedGnomonDelta = 0;
	var yInclinedGnomonDelta = -H*Math.cos(lat);
	   
	return {
		x: (xVerticalGnomon + xInclinedGnomonDelta)*(zeta(day, hours) > 0 ? 1 : -1),
		y: (yVerticalGnomon + yInclinedGnomonDelta)*(zeta(day, hours) > 0 ? 1 : -1)
	};
}

//χ – угол падения тени от гномона
function chi(hours) {
    //165 - уравнение времени обращается в 0
	var x = gnomonTopProjection(165, hours).x;
	var y = gnomonTopProjection(165, hours).y;
	
	return Math.atan2(x, y);
}

function timeClockSVG() {
	var svgText = '';

	//Sectors
	for (var hour = 4; hour < 22; hour++) {		
		svgText += '<polygon class="' + (hour < 4 || hour > 21 ? 'nighthour' : (hour % 2 == 0 ? 'evenhour' : 'oddhour')) + '" points="' + cx1(1) + ',' + cy1(1) + ' ';

		for (var hourFraction = 0; hourFraction <= clock1hourFractions; hourFraction++) {
			var hours = hour + hourFraction/clock1hourFractions;

			var clockFaceDistorsionFactor = Math.pow(clockFaceDistorsion, -Math.cos(chi(hours)));
			
			var x = clockFaceDistorsionFactor*Math.sin(chi(hours));
			var y = clockFaceDistorsionFactor*Math.cos(chi(hours));
			
			svgText += cx1(1 + x) + ',' + cy1(1 + y) + ' ';
		}

		svgText += '" />';
	}

	//Subhour lines
	for (var hour = 4; hour < 22; hour++) {
		for (var clock1hourSubdiv = 1; clock1hourSubdiv <= clock1hourSubdivs; clock1hourSubdiv++) {
			var hours = hour + clock1hourSubdiv/(clock1hourSubdivs + 1);
			
			var clockFaceDistorsionFactor = Math.pow(clockFaceDistorsion, -Math.cos(chi(hours)));
			
			var x = clockFaceDistorsionFactor*Math.sin(chi(hours));
			var y = clockFaceDistorsionFactor*Math.cos(chi(hours));

			svgText += '<line class="axisline" stroke-dasharray="3,3" x1="' + cx1(1) + '" y1="' + cy1(1) + '" x2="' + cx1(1 + x) + '" y2="' + cy1(1 + y) + '" />';
		}
	}

	//Hour text labels
	for (var hour = 4; hour <= 22; hour++) {
		var clockFaceDistorsionFactor = Math.pow(clockFaceDistorsion, -Math.cos(chi(hour)));
			
		var x = clockFaceDistorsionFactor*Math.sin(chi(hour));
		var y = clockFaceDistorsionFactor*Math.cos(chi(hour));
			
		svgText += '<text class="clocklabel" text-anchor="middle" x="' + cx1(1 + x - 0.07*x/clockFaceDistorsionFactor, 4) +
			'" y="' + cy1(1 + y - 0.07*y/clockFaceDistorsionFactor, 10) + '">' + hour + '</text>';
	}

	//North line
	svgText += '<line class="axisline" x1="' + cx1(1) + '" y1="' + cy1(1) + '" x2="' + cx1(1) + '" y2="' + cy1(1 - 200) + '" />';

	return svgText;
}

function dateClockSVG(firstDaysOfMonths, monthsLineClass, drawHourAndAxisLines) {
	var svgText = '';
	
	//Hour lines
	if (drawHourAndAxisLines)
		for (var hours = 0; hours < 24; hours++) {
			var x = 100*Math.sin(chi(hours));
			var y = 100*Math.cos(chi(hours));

			svgText += '<line class="axisline" stroke-dasharray="3,3" x1="' + cx2(1) + '" y1="' + cy2(1) + '" x2="' + cx2(1 + x) + '" y2="' + cy2(1 + y) + '" />';
		}

	//Main chart
	for (var day of firstDaysOfMonths) {
		var svgElementText = '';

		var breakLoop = false;

		for (var hour = 0; hour < 24; hour++) {
			if (breakLoop)
				break;

			for (var hourFraction = 0; hourFraction < clock2hourFractions || (hourFraction <= clock2hourFractions && hour == 23); hourFraction++) {		   
				var hours = hour + hourFraction/clock2hourFractions;
				
				var x = gnomonTopProjection(day, hours).x;
				var y = -gnomonTopProjection(day, hours).y;

				if (svgElementText == '' && Math.sin(zeta(day, hours)) > 0) {
					svgElementText += '<polyline ' +
                        (monthsLineClass == 'specialdaysline' ? 'stroke-dasharray="4,2"' : (day > 180 ? 'stroke-dasharray="15,5"' : '')) + ' class="' + monthsLineClass + '" points="';
				}

				if (svgElementText != '') {
					if (Math.sin(zeta(day, hours)) > 0) {
						svgElementText += cx2(1 + x) + ',' + cy2(1 - y) + ' ';
					}
					else {
						breakLoop = true;
						break;
					}
				}
			}  
		}

		if (svgElementText != '') {
			svgElementText += '" />';
			svgText += svgElementText;
		}
        
        if (day <= 180 && monthsLineClass != 'specialdaysline') {
                var closestX = gnomonTopProjection(day, 0).x;
                var closestY = -gnomonTopProjection(day, 0).y;
                
                var minuteFractions = 2;
                
                for (var minuteFraction = 1; minuteFraction <= 24*60*minuteFractions; minuteFraction++) {
                    if (gnomonTopProjection(day, minuteFraction/60/minuteFractions).x < -1 - clock2ShiftLeft/clock2ScaleFactor + 0.2)
                        break;
                    
                    closestX = Math.min(closestX, gnomonTopProjection(day, minuteFraction/60/minuteFractions).x);
                    
                    if (closestX == gnomonTopProjection(day, minuteFraction/60/minuteFractions).x)
                        closestY = -gnomonTopProjection(day, minuteFraction/60/minuteFractions).y;
                }
                
                svgText += '<text class="monthlabelbg" text-anchor="middle" x="' + cx2(1 + closestX) + '" y="' + cy2(1 - closestY, 3) + '">' + monthNameByFirstDayNo(day) + '</text>';
                svgText += '<text class="monthlabel" text-anchor="middle" x="' + cx2(1 + closestX) + '" y="' + cy2(1 - closestY, 3) + '">' + monthNameByFirstDayNo(day) + '</text>';
            }
            else if (day > 180 && monthsLineClass != 'specialdaysline') {
                var closestX = gnomonTopProjection(day, 0).x;
                var closestY = -gnomonTopProjection(day, 0).y;
                
                var minuteFractions = 3;
                
                for (var minuteFraction = 24*60*minuteFractions; minuteFraction >= 1; minuteFraction--) {
                    if (gnomonTopProjection(day, minuteFraction/60/minuteFractions).x > 1 + clock2ShiftLeft/clock2ScaleFactor - 0.2)
                        break;
                    
                    closestX = Math.max(closestX, gnomonTopProjection(day, minuteFraction/60/minuteFractions).x);
                    
                    if (closestX == gnomonTopProjection(day, minuteFraction/60/minuteFractions).x)
                        closestY = -gnomonTopProjection(day, minuteFraction/60/minuteFractions).y;
                }
                
                svgText += '<text class="monthlabelbg" text-anchor="middle" x="' + cx2(1 + closestX) + '" y="' + cy2(1 - closestY, 3) + '">' + monthNameByFirstDayNo(day) + '</text>';
                svgText += '<text class="monthlabel" text-anchor="middle" x="' + cx2(1 + closestX) + '" y="' + cy2(1 - closestY, 3) + '">' + monthNameByFirstDayNo(day) + '</text>';
            }
	}

	//Axis and other lines
	if (drawHourAndAxisLines) {
		svgText = '<line class="axisline" x1="' + cx2(1) + '" y1="' + cy2(1 + 100) + '" x2="' + cx2(1) + '" y2="' + cy2(1 - 100) + '" />' + svgText;
		
		svgText = '<line class="gnomonlengthmark" x1="' + cx2(1 - 0.5) + '" y1="' + cy2(1, 0.5) + '" x2="' + cx2(1 + 0.5) + '" y2="' + cy2(1, 0.5) + '" />' + svgText;
		
		svgText += '<line class="gnomontopmark" x1="' + cx2(1 - 0.05) + '" y1="' + cy2(1 - H*Math.cos(lat) - 0.05) + '" x2="' + cx2(1 + 0.05) + '" y2="' + cy2(1 - H*Math.cos(lat) + 0.05) + '" />';
		svgText += '<line class="gnomontopmark" x1="' + cx2(1 - 0.05) + '" y1="' + cy2(1 - H*Math.cos(lat) + 0.05) + '" x2="' + cx2(1 + 0.05) + '" y2="' + cy2(1 - H*Math.cos(lat) - 0.05) + '" />';
	}

	return svgText;
}

function monthNameByFirstDayNo(day) {
    switch (day) {
        case 0:
            var monthName = "Янв";
            break;
        case 31:
            var monthName = "Фев";
            break;
        case 59:
            var monthName = "Мар";
            break;
        case 90:
            var monthName = "Апр";
            break;
        case 120:
            var monthName = "Май";
            break;
        case 151:
            var monthName = "Июн";
            break;
        case 181:
            var monthName = "Июл";
            break;
        case 212:
            var monthName = "Авг";
            break;
        case 243:
            var monthName = "Сен";
            break;
        case 273:
            var monthName = "Окт";
            break;
        case 304:
            var monthName = "Ноя";
            break;
        case 334:
            var monthName = "Дек";
            break;
        default:
            var monthName = "?";
    }
    
    return monthName;
}

function timeEquationSVG() {
	var svgText = '';
	var horizontalLineGap = timeEquationHeight/8;
	var datesArray = firstDaysOfMonths.slice();
	
	if (datesArray.indexOf(0) == -1)
		datesArray.push(0);
		
	if (datesArray.indexOf(364) == -1)
		datesArray.push(364);
		
	datesArray.sort();
	
	svgText += '<text class="timeequationcaption" text-anchor="middle" x="' + cx1(1) + '" y="' + cy1(timeEquationTopY - 0.03) + '">Величина требуемой поправки (уравнение времени), минут:</text>';
	
	//Горизонтальные линии
	for (i = 0; i <= 8; i++) {
		svgText += '<line class="axisline" ' + ([0, 4, 8].indexOf(i) != -1 ? '' : 'stroke-dasharray="2,2"') + ' x1="' + cx1(timeEquationTopX) + '" y1="' + cy1(timeEquationTopY + i*horizontalLineGap) +
			'" x2="' + cx1(timeEquationTopX + timeEquationWidth) + '" y2="' + cy1(timeEquationTopY + i*horizontalLineGap) + '" />';
			
		svgText += '<text class="timeequationlabel" text-anchor="end" x="' + cx1(timeEquationTopX - 0.02) + '" y="' + cy1(timeEquationTopY + i*horizontalLineGap + 0.01) + '">' + ((4 - i)*5) + '</text>';
	}
	
	//Вертикальные линии
	for (var day of datesArray) {
		svgText += '<line class="axisline" x1="' + cx1(timeEquationTopX + day/364*timeEquationWidth) + '" y1="' + cy1(timeEquationTopY) +
			'" x2="' + cx1(timeEquationTopX + day/364*timeEquationWidth) + '" y2="' + cy1(timeEquationTopY + timeEquationHeight) + '" />';
		
		var monthName = monthNameByFirstDayNo(day);
		
		if (monthName != "?")
			svgText += '<text class="timeequationlabel" text-anchor="middle" x="' + cx1(timeEquationTopX + day/364*timeEquationWidth + 0.055) + '" y="' + cy1(timeEquationTopY + timeEquationHeight + 0.05) + '">' + monthName + '</text>';
	}
	
	svgText += '<polyline class="timeequationline" points="';
	
	for (var day = 0; day < 365; day = day + 2) {
		var x = timeEquationWidth*day/364;
		var y = -timeEquationHeight/2*time_equation_correction(day)*3;
		
		svgText += cx1(timeEquationTopX + x) + ',' + cy1(timeEquationTopY + timeEquationHeight/2 + y) + ' ';
	}

	svgText += '" />';
	
	svgText += '<text class="timeequationlabel" text-anchor="middle" x="' + cx1(1) + '" y="' + cy1(1 + 0.25) + '">Lat: ' + (Math.sign(lat)*lat*180/Math.PI).toFixed(2) + '°' + (Math.sign(lat) >= 0 ? 'N' : 'S') + '</text>';
	svgText += '<text class="timeequationlabel" text-anchor="middle" x="' + cx1(1) + '" y="' + cy1(1 + 0.3) + '">Lon: ' + (Math.sign(lon)*lon*180/Math.PI).toFixed(2) + '°' + (Math.sign(lon) >= 0 ? 'E' : 'W') + '</text>';
	svgText += '<text class="timeequationlabel" text-anchor="middle" x="' + cx1(1) + '" y="' + cy1(1 + 0.35) + '">Timezone: UTC+' + timeZone + '</text>';
		
	return svgText;
}

function drawTimeClock() {
	var svg = document.getElementById('timeclock');
	svg.innerHTML = timeClockSVG();
	svg.innerHTML += timeEquationSVG();
}

function drawDateClock() {
	var svg = document.getElementById('dateclock');
	svg.innerHTML = dateClockSVG(specialDays, 'specialdaysline', false);
	svg.innerHTML += dateClockSVG(firstDaysOfMonths, 'monthsline', true);
}

drawTimeClock();
drawDateClock();

</script>
</body>
</html>
